#!/usr/bin/env python3
"""
Sync pyproject.toml extras with actual module imports.

Scans each scitex submodule for external imports and updates
pyproject.toml optional-dependencies automatically.

Usage:
    python scripts/maintenance/sync_pyproject_extras.py
    python scripts/maintenance/sync_pyproject_extras.py --update-pyproject
    make sync-extras
"""

import argparse
import ast
import re
from pathlib import Path

from _pypi_packages import INTERNAL_MODULES, KNOWN_PACKAGES, STDLIB_MODULES


def extract_imports(filepath: Path) -> set:
    """Extract all import statements from a Python file."""
    imports = set()
    try:
        content = filepath.read_text(encoding="utf-8", errors="ignore")
        tree = ast.parse(content)
    except (SyntaxError, OSError):
        return imports

    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                imports.add(alias.name.split(".")[0])
        elif isinstance(node, ast.ImportFrom):
            if node.level == 0 and node.module:
                imports.add(node.module.split(".")[0])
    return imports


def get_package_name(import_name: str) -> str | None:
    """Convert import name to pip package name."""
    if import_name in STDLIB_MODULES or import_name in INTERNAL_MODULES:
        return None
    return KNOWN_PACKAGES.get(import_name)


def scan_module(module_path: Path) -> set:
    """Scan a module directory for all external dependencies."""
    deps = set()
    for py_file in module_path.rglob("*.py"):
        if "__pycache__" in str(py_file) or "test_" in py_file.name:
            continue
        for imp in extract_imports(py_file):
            if pkg := get_package_name(imp):
                deps.add(pkg)
    return deps


def generate_module_deps(src_dir: Path, include_empty: bool = True) -> dict:
    """Generate dependencies for each module."""
    modules_dir = src_dir / "scitex"
    module_deps = {}

    for item in sorted(modules_dir.iterdir()):
        if item.is_dir() and not item.name.startswith((".", "_")):
            if item.name == "__pycache__":
                continue
            deps = scan_module(item)
            if deps or include_empty:
                module_deps[item.name] = sorted(deps)

    return module_deps


def generate_toml_extras(module_deps: dict) -> str:
    """Generate TOML format optional-dependencies section."""
    lines = [
        "# ============================================",
        "# Module-Level Optional Dependencies",
        "# ============================================",
        "# Auto-generated by: make sync-extras",
        "# Install: pip install scitex[module_name]",
        "# Multiple: pip install scitex[audio,scholar,plt]",
        "# All: pip install scitex[all]",
        "",
        "[project.optional-dependencies]",
        "",
    ]

    for module, deps in sorted(module_deps.items()):
        if deps:
            lines.append(f"# scitex.{module}")
        else:
            lines.append(f"# scitex.{module} (stdlib only)")
        lines.append(f"{module} = [")
        for dep in deps:
            lines.append(f'    "{dep}",')
        lines.append("]")
        lines.append("")

    # Generate 'all' extra
    all_deps = set()
    for deps in module_deps.values():
        all_deps.update(deps)

    lines.append("# All module dependencies")
    lines.append("all = [")
    for dep in sorted(all_deps):
        lines.append(f'    "{dep}",')
    lines.append("]")
    lines.append("")

    # Dev dependencies
    lines.extend([
        "# Development tools",
        "dev = [",
        '    "pytest",',
        '    "pytest-cov",',
        '    "pytest-xdist",',
        '    "pytest-timeout",',
        '    "pytest-mock",',
        '    "pytest-asyncio",',
        '    "ruff",',
        '    "mypy",',
        '    "pre-commit",',
        "]",
    ])

    return "\n".join(lines)


def update_pyproject(src_dir: Path, pyproject_path: Path) -> None:
    """Update pyproject.toml with generated extras."""
    module_deps = generate_module_deps(src_dir, include_empty=True)
    extras_content = generate_toml_extras(module_deps)

    content = pyproject_path.read_text()

    # Pattern to match the optional-dependencies section
    pattern = (
        r"# =+\n# Module-Level Optional Dependencies\n# =+\n"
        r".*?"
        r"(?=\n# =+\n# Tool Configurations)"
    )

    replacement = extras_content + "\n"
    new_content = re.sub(pattern, replacement, content, flags=re.DOTALL)

    if new_content == content:
        print("Warning: Pattern not found, appending extras section")
        return

    pyproject_path.write_text(new_content)
    print(f"Updated: {pyproject_path}")
    print(f"  - {len(module_deps)} modules")
    print(f"  - {sum(len(d) for d in module_deps.values())} total dependencies")


def main():
    parser = argparse.ArgumentParser(
        description="Generate module-level dependencies for scitex"
    )
    parser.add_argument(
        "--src-dir", type=Path, default=Path(__file__).parent.parent.parent / "src",
        help="Source directory containing scitex package",
    )
    parser.add_argument(
        "--output-dir", type=Path, default=None,
        help="Output directory for requirements files",
    )
    parser.add_argument(
        "--format", choices=["requirements", "toml", "both"], default="toml",
        help="Output format",
    )
    parser.add_argument(
        "--update-pyproject", action="store_true",
        help="Update pyproject.toml directly",
    )
    parser.add_argument(
        "--include-empty", action="store_true", default=True,
        help="Include modules with no external dependencies",
    )

    args = parser.parse_args()

    if args.update_pyproject:
        pyproject = args.src_dir.parent / "pyproject.toml"
        update_pyproject(args.src_dir, pyproject)
        return

    print(f"Scanning: {args.src_dir}")
    module_deps = generate_module_deps(args.src_dir, args.include_empty)

    if args.format in ("requirements", "both") and args.output_dir:
        args.output_dir.mkdir(parents=True, exist_ok=True)
        for module, deps in module_deps.items():
            req_file = args.output_dir / f"{module}.txt"
            with open(req_file, "w") as f:
                f.write(f"# Dependencies for scitex.{module}\n")
                f.write("# Auto-generated\n\n")
                for dep in deps:
                    f.write(f"{dep}\n")
            print(f"Generated: {req_file}")

    if args.format in ("toml", "both"):
        toml_output = generate_toml_extras(module_deps)
        if args.output_dir:
            args.output_dir.mkdir(parents=True, exist_ok=True)
            toml_file = args.output_dir / "extras.toml"
            toml_file.write_text(toml_output)
            print(f"\nGenerated: {toml_file}")
        print("\n" + "=" * 60)
        print("TOML extras output:")
        print("=" * 60)
        print(toml_output)


if __name__ == "__main__":
    main()
