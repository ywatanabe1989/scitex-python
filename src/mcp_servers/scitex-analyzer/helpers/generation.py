#!/usr/bin/env python3
# Timestamp: "2025-12-28 (ywatanabe)"
# File: ./mcp_servers/scitex-analyzer/helpers/generation.py

"""Project generation helpers."""

from collections import defaultdict, deque
from pathlib import Path
from typing import Any, Dict, List


async def create_config_files(project_path: Path, project_type: str) -> None:
    """Create standard configuration files.

    Parameters
    ----------
    project_path : Path
        Path to the project directory
    project_type : str
        Type of project being created
    """
    config_dir = project_path / "config"

    # PATH.yaml
    path_config = {
        "DATA": "data",
        "RESULTS": "results",
        "FIGURES": "figures",
        "SCRIPTS": "scripts",
    }
    (config_dir / "PATH.yaml").write_text(f"# Path configuration\n{path_config}")

    # PARAMS.yaml
    params_config = {
        "ANALYSIS_THRESHOLD": 0.05,
        "RANDOM_SEED": 42,
        "BATCH_SIZE": 32,
    }
    (config_dir / "PARAMS.yaml").write_text(f"# Analysis parameters\n{params_config}")

    # COLORS.yaml
    colors_config = {
        "PRIMARY": "#1f77b4",
        "SECONDARY": "#ff7f0e",
        "SUCCESS": "#2ca02c",
        "DANGER": "#d62728",
    }
    (config_dir / "COLORS.yaml").write_text(f"# Color scheme\n{colors_config}")


async def create_main_script(
    project_path: Path, project_name: str, project_type: str
) -> str:
    """Create main script template.

    Parameters
    ----------
    project_path : Path
        Path to the project directory
    project_name : str
        Name of the project
    project_type : str
        Type of project being created

    Returns
    -------
    str
        The script content created
    """
    script_content = f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
{project_name}: Main analysis script
Generated by SciTeX MCP Server
"""

import scitex as stx

CONFIG = stx.io.load_configs()

@stx.gen.start()
def main():
    """Main entry point."""
    print(f"Starting {project_name} analysis...")

    # Your analysis code here

    print("Analysis complete!")

if __name__ == "__main__":
    main()
'''

    script_path = project_path / "scripts" / "main.py"
    script_path.write_text(script_content)
    return script_content


async def create_readme(
    project_name: str, project_type: str, features: List[str]
) -> str:
    """Create README template.

    Parameters
    ----------
    project_name : str
        Name of the project
    project_type : str
        Type of project being created
    features : list of str
        List of features to include

    Returns
    -------
    str
        README content
    """
    return f"""# {project_name}

A {project_type} project using the SciTeX framework.

## Features

{chr(10).join(f"- {feature}" for feature in features)}

## Quick Start

```bash
# Install dependencies
pip install -r requirements.txt

# Run main analysis
python scripts/main.py
```

## Project Structure

- `scripts/` - Analysis scripts
- `config/` - Configuration files
- `data/` - Input data
- `results/` - Output results
- `examples/` - Example usage
- `tests/` - Test files

## Configuration

Edit configuration files in `config/`:
- `PATH.yaml` - File paths
- `PARAMS.yaml` - Analysis parameters
- `COLORS.yaml` - Color schemes

## Generated by SciTeX MCP Server
"""


async def create_requirements(project_type: str, features: List[str]) -> str:
    """Create requirements.txt.

    Parameters
    ----------
    project_type : str
        Type of project being created
    features : list of str
        List of features to include

    Returns
    -------
    str
        Requirements content
    """
    requirements = ["scitex", "numpy", "pandas", "matplotlib"]

    if "ml" in features:
        requirements.extend(["scikit-learn", "scipy"])
    if "stats" in features:
        requirements.extend(["scipy", "statsmodels"])
    if "testing" in features:
        requirements.append("pytest")

    return chr(10).join(requirements) + chr(10)


async def create_example_scripts(project_path: Path, project_type: str) -> List[str]:
    """Create example scripts.

    Parameters
    ----------
    project_path : Path
        Path to the project directory
    project_type : str
        Type of project being created

    Returns
    -------
    list of str
        List of created file paths
    """
    examples_dir = project_path / "examples"
    files = []

    basic_example = '''#!/usr/bin/env python3
import scitex as stx
import numpy as np

CONFIG = stx.io.load_configs()

def example_analysis():
    """Example SciTeX analysis."""
    # Generate sample data
    data = np.random.randn(100, 3)

    # Save with SciTeX
    stx.io.save(data, './results/sample_data.csv', symlink_from_cwd=True)

    # Create plot
    fig, ax = stx.plt.subplots()
    ax.plot(data[:, 0], label='Series 1')
    ax.plot(data[:, 1], label='Series 2')
    ax.legend()

    stx.io.save(fig, './figures/example_plot.png', symlink_from_cwd=True)

if __name__ == "__main__":
    example_analysis()
'''

    (examples_dir / "basic_example.py").write_text(basic_example)
    files.append("examples/basic_example.py")

    return files


async def create_test_templates(project_path: Path) -> List[str]:
    """Create test templates.

    Parameters
    ----------
    project_path : Path
        Path to the project directory

    Returns
    -------
    list of str
        List of created file paths
    """
    tests_dir = project_path / "tests"
    files = []

    test_content = '''#!/usr/bin/env python3
import pytest
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

def test_basic_functionality():
    """Test basic project functionality."""
    assert True  # Replace with actual tests

def test_configuration_loading():
    """Test configuration loading."""
    import scitex as stx
    try:
        config = stx.io.load_configs()
        assert config is not None
    except:
        pytest.skip("Configuration files not found")

if __name__ == "__main__":
    pytest.main([__file__])
'''

    (tests_dir / "test_main.py").write_text(test_content)
    files.append("tests/test_main.py")

    return files


def resolve_dependencies(scripts: Dict, dependencies: Dict) -> Dict[str, Any]:
    """Resolve script execution order based on dependencies.

    Parameters
    ----------
    scripts : dict
        Dictionary of scripts
    dependencies : dict
        Dictionary of script dependencies

    Returns
    -------
    dict
        Either {'order': list} or {'error': str}
    """
    graph = defaultdict(list)
    in_degree = defaultdict(int)

    # Build graph
    for script in scripts:
        in_degree[script] = 0

    for script, deps in dependencies.items():
        for dep in deps:
            graph[dep].append(script)
            in_degree[script] += 1

    # Topological sort
    queue = deque([script for script in scripts if in_degree[script] == 0])
    order = []

    while queue:
        script = queue.popleft()
        order.append(script)

        for neighbor in graph[script]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    if len(order) != len(scripts):
        return {"error": "Circular dependency detected"}

    return {"order": order}


# EOF
